# server.py
# BelluGames Website Backend - FINAL LAUNCHER/REDIRECTOR VERSION

import asyncio
import json
import logging
import os
import random
import sqlite3
import string
from datetime import datetime, timedelta, timezone

import aiohttp_cors
import jwt
from aiohttp import web
from werkzeug.security import check_password_hash, generate_password_hash

# --- CONFIGURATION (EDIT THESE) ---
DB_NAME = "bellugames_website.db"
rgb(255,255,255) = "https://life-web-arch.github.io/WebBelluGames/"
JWT_SECRET = "wmL53&b^yT7**!kO&sXL3vi5Q45baeR*5eNE!6BGRK!3VYcoMllB^DNib71qbLC$f38Sh039NVWubhYM@gYxEc%eiSKyz@IZ^mDnJDuRAa^FFF#Zt26$cLzg1YZmptvO"
JWT_ALGORITHM = "HS256"
MINI_APP_GRID_SIZE = 5

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# (Database, Auth, and Game Logic sections are unchanged from previous correct versions)
def db_connect(): return sqlite3.connect(DB_NAME, timeout=10)
def setup_database():
    conn = db_connect(); c = conn.cursor(); c.execute("PRAGMA user_version")
    if c.fetchone()[0] < 1:
        logging.info("Creating initial database schema (v1)...")
        c.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT UNIQUE NOT NULL, password_hash TEXT NOT NULL, created_at TEXT NOT NULL)")
        c.execute("PRAGMA user_version = 1"); conn.commit()
    conn.close()
def login_required(handler):
    async def middleware(request):
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '): return web.json_response({'error': 'Authorization header missing or invalid'}, status=401)
        token = auth_header.split(' ')[1]
        try:
            payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
            request['user'] = {'id': payload['user_id'], 'username': payload['username']}
        except jwt.ExpiredSignatureError: return web.json_response({'error': 'Token has expired'}, status=401)
        except jwt.InvalidTokenError: return web.json_response({'error': 'Invalid token'}, status=401)
        return await handler(request)
    return middleware
async def handle_register(request):
    data = await request.json(); username = data.get('username'); password = data.get('password')
    if not username or not password or len(username) < 3 or len(password) < 6: return web.json_response({'error': 'Username must be >= 3 chars, password >= 6 chars'}, status=400)
    password_hash = generate_password_hash(password)
    try:
        conn = db_connect(); c = conn.cursor(); c.execute("INSERT INTO users (username, password_hash, created_at) VALUES (?, ?, ?)", (username, password_hash, datetime.now(timezone.utc).isoformat())); conn.commit(); conn.close()
        return web.json_response({'status': 'ok', 'message': 'User created successfully'}, status=201)
    except sqlite3.IntegrityError: return web.json_response({'error': 'Username already exists'}, status=409)
    except Exception as e: logging.error(f"Registration error: {e}"); return web.json_response({'error': 'Server error during registration'}, status=500)
async def handle_login(request):
    data = await request.json(); username = data.get('username'); password = data.get('password')
    conn = db_connect(); conn.row_factory = sqlite3.Row; user = conn.execute("SELECT * FROM users WHERE username = ?", (username,)).fetchone(); conn.close()
    if user and check_password_hash(user['password_hash'], password):
        payload = {'user_id': user['id'], 'username': user['username'], 'exp': datetime.now(timezone.utc) + timedelta(days=7)}
        token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)
        return web.json_response({'status': 'ok', 'token': token})
    return web.json_response({'error': 'Invalid username or password'}, status=401)
@login_required
async def handle_get_me(request): return web.json_response({'user': request['user']})
def _check_box_completion(board_data, row, col):
    lines = board_data['lines']
    return bool(lines['h'][row][col] and lines['h'][row + 1][col] and lines['v'][row][col] and lines['v'][row][col + 1])
@login_required
async def handle_create_game(request):
    user = request['user']; app = request.app; room_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=4))
    p1_info = {'id': user['id'], 'name': user['username'], 'symbol': 'ðŸ”µ'}
    p2_info = {'id': None, 'name': 'Waiting...', 'symbol': 'ðŸ”´'}
    initial_board_data = {'grid_size': MINI_APP_GRID_SIZE, 'lines': {'h': [[None] * MINI_APP_GRID_SIZE for _ in range(MINI_APP_GRID_SIZE + 1)], 'v': [[None] * (MINI_APP_GRID_SIZE + 1) for _ in range(MINI_APP_GRID_SIZE)]}, 'boxes': [[None] * MINI_APP_GRID_SIZE for _ in range(MINI_APP_GRID_SIZE)], 'scores': {p1_info['id']: 0}, 'player1': p1_info, 'player2': p2_info, 'current_turn': user['id'], 'status': 'waiting', 'winner_id': None}
    app['active_games'][room_code] = {'game_type': 'dots_and_boxes', 'host_id': user['id'], 'players': {user['id']: {'name': user['username'], 'symbol': 'ðŸ”µ'}}, 'board_data': initial_board_data}
    logging.info(f"User {user['username']} created room {room_code}")
    return web.json_response({'status': 'ok', 'room_code': room_code})
@login_required
async def handle_join_game(request):
    user = request['user']; app = request.app; room_code = request.match_info.get('room_code'); game_state = app['active_games'].get(room_code)
    if not game_state or game_state['board_data']['status'] != 'waiting': return web.json_response({'error': 'Room not found or is already full'}, status=404)
    if user['id'] == game_state['host_id']: return web.json_response({'error': "You can't join your own game"}, status=400)
    game_state['players'][user['id']] = {'name': user['username'], 'symbol': 'ðŸ”´'}; game_state['board_data']['player2']['id'] = user['id']; game_state['board_data']['player2']['name'] = user['username']; game_state['board_data']['scores'][user['id']] = 0; game_state['board_data']['status'] = 'in_progress'
    logging.info(f"User {user['username']} joined room {room_code}. Game starting.")
    return web.json_response({'status': 'ok', 'message': 'Joined game successfully'})
@login_required
async def handle_get_game_state(request):
    user = request['user']; app = request.app; room_code = request.match_info.get('room_code'); game_state = app['active_games'].get(room_code)
    if not game_state or user['id'] not in game_state['players']: return web.json_response({'error': 'Game not found or you are not a player'}, status=404)
    return web.json_response(game_state['board_data'])
@login_required
async def handle_make_move(request):
    user = request['user']; app = request.app; room_code = request.match_info.get('room_code'); game_state = app['active_games'].get(room_code)
    if not game_state or user['id'] not in game_state['players']: return web.json_response({'error': 'Game not found'}, status=404)
    board_data = game_state['board_data']
    if board_data['current_turn'] != user['id']: return web.json_response({'error': 'Not your turn'}, status=400)
    data = await request.json(); move = data.get('move'); lines = board_data['lines']
    if lines[move['type']][move['row']][move['col']] is not None: return web.json_response({'error': 'Line already taken'}, status=400)
    lines[move['type']][move['row']][move['col']] = user['id']; boxes_completed_this_turn = 0
    if move['type'] == 'h':
        if move['row'] > 0 and _check_box_completion(board_data, move['row'] - 1, move['col']):
            if board_data['boxes'][move['row'] - 1][move['col']] is None: board_data['boxes'][move['row'] - 1][move['col']] = user['id']; boxes_completed_this_turn += 1
        if move['row'] < MINI_APP_GRID_SIZE and _check_box_completion(board_data, move['row'], move['col']):
            if board_data['boxes'][move['row']][move['col']] is None: board_data['boxes'][move['row']][move['col']] = user['id']; boxes_completed_this_turn += 1
    else:
        if move['col'] > 0 and _check_box_completion(board_data, move['row'], move['col'] - 1):
            if board_data['boxes'][move['row']][move['col'] - 1] is None: board_data['boxes'][move['row']][move['col'] - 1] = user['id']; boxes_completed_this_turn += 1
        if move['col'] < MINI_APP_GRID_SIZE and _check_box_completion(board_data, move['row'], move['col']):
            if board_data['boxes'][move['row']][move['col']] is None: board_data['boxes'][move['row']][move['col']] = user['id']; boxes_completed_this_turn += 1
    if boxes_completed_this_turn > 0: board_data['scores'][user['id']] += boxes_completed_this_turn
    else: opponent_id = next(pid for pid in game_state['players'] if pid != user['id']); board_data['current_turn'] = opponent_id
    if sum(board_data['scores'].values()) >= (MINI_APP_GRID_SIZE ** 2):
        board_data['status'] = 'finished'; p1_id = board_data['player1']['id']; p2_id = board_data['player2']['id']; p1_score = board_data['scores'].get(p1_id, 0); p2_score = board_data['scores'].get(p2_id, 0)
        if p1_score > p2_score: board_data['winner_id'] = p1_id
        elif p2_score > p1_score: board_data['winner_id'] = p2_id
        else: board_data['winner_id'] = 0
    return web.json_response({'status': 'ok'})
@login_required
async def handle_get_open_games(request):
    app = request.app; open_games = []
    for code, state in app['active_games'].items():
        if state['board_data']['status'] == 'waiting': open_games.append({'room_code': code, 'host': state['board_data']['player1']['name']})
    return web.json_response(open_games)

# ==============================================================================
# SERVER & AUTOMATIC TUNNEL MANAGEMENT
# ==============================================================================

async def handle_launcher(request: web.Request):
    """
    Serves an HTML page that immediately redirects the user to the GitHub Pages
    site with the correct, dynamic tunnel URL and password parameters.
    """
    app = request.app
    tunnel_info = app.get('tunnel_info', {})
    tunnel_url = tunnel_info.get('url')
    tunnel_pwd = tunnel_info.get('password')

    if not tunnel_url or not tunnel_pwd:
        return web.Response(text="<h1>Server is starting...</h1><p>The tunnel is not ready yet. Please refresh in a few moments.</p>", content_type='text/html')

    final_url = f"{GITHUB_PAGES_URL}?tunnel_url={tunnel_url}&tunnel_pwd={tunnel_pwd}"
    html_content = f"""
    <!DOCTYPE html><html><head><title>Loading BelluGames...</title><meta http-equiv="refresh" content="0; url={final_url}" /><style>body {{ font-family: sans-serif; background-color: #1a1a1a; color: #fff; text-align: center; padding-top: 20%; }}</style></head><body><h1>Redirecting to BelluGames...</h1><p>If you are not redirected automatically, <a href="{final_url}">click here</a>.</p><script>window.location.replace("{final_url}");</script></body></html>
    """
    return web.Response(text=html_content, content_type='text/html')

async def manage_tunnel(app: web.Application):
    """
    Launches and manages the node tunnel.js subprocess with non-blocking,
    real-time stream reading to prevent deadlocks.
    """
    retry_delay_seconds = 10
    while True:
        logging.info("Attempting to start tunnel process...")
        process = None
        try:
            process = await asyncio.create_subprocess_exec(
                'node', 'tunnel.js', # No subdomain argument needed anymore
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            app['tunnel_info']['url'] = None
            app['tunnel_info']['password'] = None

            url_found = False
            while not url_found:
                try:
                    line = await asyncio.wait_for(process.stdout.readline(), timeout=30.0)
                    if not line: break
                    
                    decoded_line = line.decode('utf-8').strip()
                    logging.info(f"[Tunnel Script - stdout]: {decoded_line}")
                    
                    if decoded_line.startswith('https://'):
                        url_found = True
                        tunnel_url = decoded_line
                        app['tunnel_info']['url'] = tunnel_url
                        logging.info(f"SUCCESS: Captured public tunnel URL: {tunnel_url}")
                        
                        await asyncio.sleep(2)
                        curl_proc = await asyncio.create_subprocess_exec('curl', 'https://loca.lt/mytunnelpassword', stdout=asyncio.subprocess.PIPE)
                        curl_stdout, _ = await curl_proc.communicate()
                        password = curl_stdout.decode('utf-8').strip()
                        app['tunnel_info']['password'] = password
                        logging.info(f"SUCCESS: Captured tunnel password: {password}")
                
                except asyncio.TimeoutError:
                    logging.error("Timeout: Tunnel script did not provide a URL within 30 seconds. Killing and restarting.")
                    process.kill()
                    await process.wait()
                    break

            if url_found:
                logging.info("Tunnel is live. Monitoring process for crashes.")
                await process.wait()
                logging.warning(f"Tunnel process terminated with code {process.returncode}. It will be restarted.")

            stderr_output = await process.stderr.read()
            if stderr_output:
                logging.error(f"[Tunnel Script - stderr]: {stderr_output.decode('utf-8').strip()}")

        except FileNotFoundError:
            logging.critical("FATAL: 'node' or 'curl' not found. Please install them in Termux (`pkg install nodejs curl`).")
            await asyncio.sleep(300)
        except Exception as e:
            logging.error(f"An unexpected error occurred in the tunnel manager: {e}", exc_info=True)
            if process and process.returncode is None: process.kill()
        
        app['tunnel_info']['url'] = None
        app['tunnel_info']['password'] = None
        await asyncio.sleep(retry_delay_seconds)

async def main():
    setup_database()
    app = web.Application()
    app['active_games'] = {}
    app['tunnel_info'] = {}

    cors = aiohttp_cors.setup(app, defaults={"*": aiohttp_cors.ResourceOptions(allow_credentials=True, expose_headers="*", allow_headers="*", allow_methods="*")})
    
    # The root URL is now the launcher
    app.router.add_get('/', handle_launcher)
    
    # API Routes
    app.router.add_post('/api/register', handle_register)
    app.router.add_post('/api/login', handle_login)
    app.router.add_get('/api/me', handle_get_me)
    app.router.add_post('/api/games', handle_create_game)
    app.router.add_get('/api/games', handle_get_open_games)
    app.router.add_post('/api/games/{room_code}/join', handle_join_game)
    app.router.add_get('/api/games/{room_code}', handle_get_game_state)
    app.router.add_post('/api/games/{room_code}/move', handle_make_move)
    # This endpoint is no longer needed by the launcher flow, but is kept for the error recovery view
    app.router.add_get('/api/tunnel-info', handle_get_tunnel_info)

    for route in list(app.router.routes()): cors.add(route)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', 8080)
    
    logging.info("Starting web server...")
    await site.start()
    
    tunnel_task = asyncio.create_task(manage_tunnel(app))
    logging.info("Server is running. Waiting for tunnel to provide public URL.")
    
    await tunnel_task

if __name__ == "__main__":
    if GITHUB_PAGES_URL == "https://your-github-username.github.io/your-repo-name/":
        logging.critical("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        logging.critical("!!! CRITICAL: You must set your GITHUB_PAGES_URL in server.py !!!")
        logging.critical("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("Server stopped manually.")
